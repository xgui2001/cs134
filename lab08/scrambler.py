# The Enigma scrambler.
# STUDENTS: DO NOT EDIT THIS FILE.
"""This module implements an Enigma scrambler, with three rotors.
You can read about the scrambler at
  https://en.wikipedia.org/wiki/Enigma_rotor_details

The scrambler is responsible for mapping plaintext keypresses to encoded
characters, shown in lights on the Engima machine.

The machine is composed of 3 rotors and a reflector:
          v--  left rotor <--- middle rotor <--- right rotor <--- keyboard
   reflector
          ---> left rotor ---> middle rotor ---> right rotor ---> lights

Each rotor defines a mapping of letters to letters going from right to left.
The inverse of that mapping is used on signals going left to right.
The reflector defines a mapping of letters to letters and changes the
direction of the signal back through the rotors.

As each character is mapped, the rightmost rotor rotates, changing the
mapping.  After 26 rotations, the middle rotor is forced to rotate.
After 26 rotations of the middle rotor, the left rotor rotates.

A 3-letter key was used to set the initial rotor position: the rotors are
marked with letters of the alphabet and operator initially rotates the
rotors to display the letters of the key.  As keys are pressed, the
rotors spin and the key "increases" alphabetically.

Encryption:
The operator spins the rotors to the starting key.
The plaintext is pressed on the keyboard, and the respective lights are
the encoded message.

Decryption:
Same as encryption!
The operator spins the rotors to the same starting key.
The encoded message is entered at the keyboard, and the respective lights are
the plaintext.

The Engima could be reconfigured by permuting or replacing the rotors.
In addition, the reflector could be swapped out.

We have made some basic (but unimportant) simplifications, but this
device is quite capable of generating hard-to-decode encodings.

Simulating the Enigma:
This interface allows you to encode a single uppercase letter using
the function "scrambler".  The character returned is the encoded letter.
This function also accepts a parameter, "spin", which is simply
how far the rotors have advanced after having displayed AAA.  After each
call to scramble, you must advance spin by 1 to simulate the turning of the
rotors.

You can replace or rearrange the rotors by specifying the rotors argument.
The rotors[0] is the left rotor, rotor[2] is the right.  Similarly the
reflector can be swapped out.  By default we use
    rotors = [EngimaI, EnigmaII, EnigmaIII], reflector=ReflectorB
These mappings are simple strings as specified on the wikipedia page
mentioned above.

BE AWARE: the same starting value of "spin" must be used to encode and decode
the same message.
"""

__all__ = ['scrambler', 'EnigmaI', 'EnigmaII', 'EnigmaIII', 'ReflectorB']

EnigmaI = 'EKMFLGDQVZNTOWYHXUSPAIBRCJ'
EnigmaII = 'AJDKSIRUXBLHWTMCQGZNPYFVOE'
EnigmaIII = 'BDFHJLCPRTXVZNYEIWGAKMUSQO'
ReflectorB = 'YRUHQSLDPXNGOKMIEBFZCWVJAT'

def _a2i(a):
    """alpha to letter code."""
    assert a.isalpha() and len(a) == 1
    return (ord(a) & 31)-1

def _i2a(i):
    """letter code to lower alpha"""
    return 'abcdefghijklmnopqrstuvwxyz'[i%26]

def _i2A(i):
    """letter code to upper alpha"""
    return 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'[i%26]

def _map(c,mapping):
    """Map character c through a rotor mapping."""
    return mapping[_a2i(c)]

def _inverse(mapping):
    """Generate the inverse of mapping. ie. c -> mapping -> inverse -> c.
    For translating characters going back through the rotors."""
    return ''.join([_i2A(mapping.index(_i2A(i))) for i in range(26)])

def _rotate(mapping,rotation):
    """Rotate the mapping."""
    return mapping[-rotation:]+mapping[:-rotation]

def scrambler(c,spin=0,key=None,rotors=None,reflector=None):
    """Map a key press of letter c, through rotors, to the reflector
    and back through rotors to produce the encoded character.
    Spin typically is zero and increases as characters are encoded.
    Its value causes the rotors to spin.   You can specify a normalized starting
    key with "key" (see module documentation).
    WARNING: This function only maps uppercase letters to uppercase letters.
    """
    if rotors is None:
        rotors = [EnigmaI, EnigmaII, EnigmaIII]
    if reflector is None:
        reflector = ReflectorB
    if (key is not None and len(key) == 3):
        spin += (_a2i(key[0])*26+_a2i(key[1]))*26+_a2i(key[2])
            
    # setup
    spin1 = spin//26//26
    rotor1 = _rotate(rotors[0],spin1)
    irotor1 = _inverse(rotor1)

    spin2 = (spin//26)%26
    rotor2 = _rotate(rotors[1],spin2)
    irotor2 = _inverse(rotor2)
    
    spin3 = spin%26
    rotor3 = _rotate(rotors[2],spin3)
    irotor3 = _inverse(rotor3)
    
    # do the mapping
    i1 = _map(c,rotor3)
    i2 = _map(i1,rotor2)
    i3 = _map(i2,rotor1)
    o0 = _map(i3,reflector)
    o1 = _map(o0,irotor1)
    o2 = _map(o1,irotor2)
    out = _map(o2,irotor3)
    return out

if __name__ == "__main__":
    message = open('turing.txt').read()
    for i in range(35):
        print(scrambler(message[i],i,key='TUR'), end='')
    print()
